#include "HugeInteger.h"
#include <random>
#include <algorithm>
#include <stdexcept>
#include <ctime>

// CONSTRUCTOR: default (we'll just output int 1 if no input is given)
HugeInteger::HugeInteger(){
	isNegative=false;
	length=1;
	// dynamically allocate space for int array of length 1 into DATA
	data = new int [length];
}

// CONSTRUCTOR: create HugeInt based on string
HugeInteger::HugeInteger(const string& val) {

	// error handling with array and pointer
	char possible_digits[10]={'0','1','2','3','4','5','6','7','8','9'};
	char *p2;
	char possible_first_digit[11]={'-','0','1','2','3','4','5','6','7','8','9'};
	char *p1;

	// error handling - first digit of val string
	// iterate pointer thru addresses of first digit array and check if val[0] is there
	p1 = find(possible_first_digit, possible_first_digit+11, val[0]);

	// find returns pointer to last element if it doesn't find val[0]
	if(p1 == possible_first_digit+11){
		// invalid first digit, invalid input
		// throw exception
		throw invalid_argument("Invalid string input. Make sure first digit is '-' or 1-9.");
		// throw immediately terminates execution (no need for return)
	}


	// error handling - following digits of val string
	for(unsigned int i=1;i<val.size();i++){
		p2 = find(possible_digits,possible_digits+10,val[i]);
		if(p2 == possible_digits+10){
			// val[i] was not found in list of acceptable digits
			throw invalid_argument("Invalid string input. Make sure you're using decimals 0-9.");
		}
	}


	// if it's negative, so there's a dash at beginning
	if(val[0]=='-'){
		isNegative=1; // true
		// length (num. of DIGITS) will be string size - 1 for "-"
		length=val.size()-1;
	}
	// if it's not negative, so there's no dash
	else{
		isNegative=0; // false
		// length is just length of string
		length=val.size();
	}

	// allocate memory space for data array with 'new' keyword; everything is initialized to 0
	// kinda like a placeholder for the space
	data = new int [length];

	// create pointer to val (input string)
	const char* p = &val[0];
	if(*p=='-'){
		// increment position by 1 (p++ increments by size of char) if there's a negative at val[0]
		p++;
	}

	// iterate through string to fill dynamically allocated array
	// BUT WE USE POINTER p instead of val to avoid negative at beginning (p starts at val[0] if it's a digit, and starts at val[1] if not, continues until we reach length of data array, not including "-")
	for(int i=0;i<length;i++){
		// convert from ascii by adding '0'
		data[i] = p[i]-'0';
	}

	// testing purposes
	/*
	for(int i=0;i<length;i++){
		printf("r %d \n",data[i]);
	}
	*/

}

// CONSTRUCTOR: create random HugeInteger of n digits
HugeInteger::HugeInteger(int n) {
	// error handling
	if(n<1){
		throw invalid_argument("Invalid decimal input. Make sure you're entering an integer >0.");
	}


	// static means (whenever u call huge integer, counter doesn't get restarted, so it keeps incrementing)
	// unsigned means it'll go back to 0 after reaching max (if we called function thatt many times)
	static int unsigned counter=0;
	// standard mersenne_twister_engine seeded with counter (defined above) + n
	mt19937 gen(counter+n);
	// gives constantly a new seed to GEN so that there's a new sequence - new value - each time we call function
	counter++;
	uniform_int_distribution<int>distr(0,9);

	// decide sign using a pseudorandom operation
	// random number generated by distrib(gen)
	if (distr(gen)-5>=0){
		// negative if the random number is 5,6,7,8,9
		isNegative=1;
		// testing purposes
		printf("negative \n");
	}
	else{
		// positive if the random number is 0,1,2,3,4
		isNegative=0;
		// testing purposes
		printf("positive \n");
	}

	length=n;

	// initialize & allocate data array
	data = new int [length];


	// use a while loop to make sure data[0] isn't 0
	// so we'll keep looping until it gives something other than 0 to start with
	*data=0;
	while(*data==0){
		// assigning value *data = data[0]
		*data=distr(gen);
	}

	// randomly generate remaining digits
	// starting at 1 cuz we already got data[0] above to make sure it wasn't 0
	for(int i=1;i<n;i++){
		data[i]=distr(gen);
	}


}

// COPY CONSTRUCTOR --ensure we wont have memory space issues with destructor (rule of 3... see below)
HugeInteger::HugeInteger(const HugeInteger& num){
	// this-> notation is implicit here
	isNegative=num.isNegative;
	length=num.length;
	// allocate data array
	data = new int [length];
	for(int i=0;i<length;i++){
		data[i]=num.data[i];
	}

}


// DESTRUCTOR
// must delete things stored in the heap (dynamically allocated) because they are static (never get deleted otherwise)
// don't have to delete things stored in the stack (not dynamically allocated) because they get deleted automatically at the end of the function call
HugeInteger::~HugeInteger(){
	// array deletion syntax
	delete[] data;
}



// default fromsub variable to false
// only make it true if we're calling from sub function
// h + this, -h - this
HugeInteger HugeInteger::add(const HugeInteger& h, bool fromSubFunc) {
	HugeInteger result;

	// see if we're gonna need substraction or addition

	// see if we're coming from sub function
	if(fromSubFunc==true && h.isNegative != this->isNegative){
		// then we're coming from the substraction function, so we use the logic there
		if(this->isNegative==true){
			// - this - h
			result.isNegative=true;
		}
		else{
			// + this + h
			result.isNegative=false;
		}
	}

	// we're not coming from sub function, regular addition this + h
	else if(fromSubFunc==false && h.isNegative != this->isNegative){
		return this->HugeInteger::subtract(h,true);
	}
	else if(h.isNegative == true && this->isNegative == true){
		// both numbers are negative, so sum hugeint will also be negative
		result.isNegative = true;
	}
	else{
		result.isNegative=false;
	}


	// length will be at most one digit longer than greatest size (1 digit more due to carry)
	// get iteration number n --> run through size of greatest array
	// declare n outside of if scope... size of LARGER array (we don't yet know which one...)
	int n=0;
	// m is size of SHORTER array
	int m=0;

	// initialize pointers to bigger/smaller arrays
	// nptr is pointer to LARGER
	int* nptr;
	// mptr is pointer to SHORTER
	int* mptr;

	if(h.length<=this->length){
		// this data array (n) is larger than h data array (m)
		n=this->length;
		m=h.length;
		nptr = this->data;
		mptr = h.data;
	}
	else{
		// h data array (n) is larger than this data array (m)
		n=h.length;
		m=this->length;
		nptr = h.data;
		mptr = this->data;
	}

	/*
	// print arrays - testing purposes
	int* ntemp = nptr;
	int* mtemp = mptr;

	printf("big \n");
	for(int t=0;t<n;t++){printf("%d",*ntemp);ntemp++;}
	printf("\n");

	printf("smol \n");
	for(int t=0;t<m;t++){printf("%d",*mtemp);mtemp++;}
	printf("\n");
	*/

	// allocate memory for result's data
	// but we don't know the exact length yet, so we'll allocate a temporary array
	// we know the max length is n+1
	int* temp_arr = new int [n+1];


	// initialize carry
	int carry=0;

	// arrays must be add in reverse direction (starting with ones column)
	// we'll assign values to temp_arr using "reverse" indexing cuz we wanna add carry or not at the END, depending, without having to shift entire array
	// so we'll reverse our temp data array instead of shifting all the data

	// j serves as variable to loop thru temp_array in a forwards direction
	// notice j keeps track of how many elements there are in temp array (we'll use this later)
	int j=0;

	// smaller array counter (m with k)
	int k=m-1;

	// larger array counter (n with i) - drives for loop
	for(int i=n-1;i>=0;i--){

		int tempsum = 0;

		// take larger + smaller until k=0 (finished thru smaller), then take larger only (+ any carry of course)
		if(k>=0){
			tempsum = nptr[i]+mptr[k]+carry;
		}

		else{
			// now we only want larger (n with i)
			tempsum = nptr[i]+carry;
		}

		// find resulting (last) digit (ones place of temp)
		temp_arr[j]=tempsum%10;

		// find carry (first) value (tens place of temp)
		// but we know max value of temp will be <100, so integer division comes clutch here
		carry=tempsum/10;

		// increment j - looping thru temp array
		j++;
		// decrement k - looping thru smaller array (backwards)
		k--;
	}

	// if we terminate with non zero carry, our length will be n+1
	// result array will take values of temp_array IN REVERSE + value of carry
	if(carry!=0){
		result.length=n+1;
		// allocate data
		result.data = new int [result.length];
		result.data[0]=carry;
	}
	else{
		// otherwise, length is simply n
		result.length=n;
		result.data = new int [result.length];
	}

	/*
	// print temp array
	printf("before \n");
	for(int t=0;t<j;t++){printf("%d",temp_arr[t]);}
	printf("\n");
	*/

	// j stores number of elements in temp array --> based on for loop above
	// reverse temp array
	for(int i=0;i<j/2;i++){
		int temp=temp_arr[i];
		// preserve value
		temp_arr[i]=temp_arr[j-i-1];
		temp_arr[j-i-1]=temp;
	}

	/*
	// print temp array
	printf("after \n");
	for(int t=0;t<j;t++){printf("%d",temp_arr[t]);}
	printf("\n");
	*/

	// create pointer to point to beginning of result.data
	int* ptemp = result.data;

	if(carry!=0){
		ptemp++;
		// start at index 1 of result.data instead of 0, cuz we've already assigned result.data[0]=carry
		// but STILL INDEX 0 OF TEMP_ARR (we'll use z for this)
	}

	int z=0;

	while(ptemp!=(result.data+result.length)){
		// while pointer is not out of range, that is address result.data has not incremented to past length
		// assign result.data value of temp_arr
		*ptemp = temp_arr[z];
		ptemp++;
		z++;
	}

	// free space
	delete[] temp_arr;

	return result;

}

HugeInteger HugeInteger::subtract(const HugeInteger& h,bool fromAddFunc) {
	HugeInteger result;

	// operation: [this - h]

	// initialize pointers and length variables
	// n is for longer int, m is for shorter one
	int n=0;
	int m=0;
	int* nptr;
	int* mptr;

	/*
	if(fromAddFunc==true && h.isNegative==true){
		// means they have diff signs and we wanna do this - h or h - this
		// but the problem is h is negative or this is negative and we want to make them both positive
		// we wanna conduct this - h so we want a negative result

	}

	else if(fromAddFunc==true && this->isNegative==true){
		// we wanna conduct h - this
	}
	*/

	// if h is negative and this is positive: this + h
	// if h is positive and this is negative: -h - this
	if(fromAddFunc==false && this->isNegative != h.isNegative){
		return this->HugeInteger::add(h,true);
	}

	// must be from add function if thisneg != hneg
	else if(h.length<this->length){
		// this data array (n) is larger than h data array (m)
		n=this->length;
		m=h.length;
		nptr = this->data;
		mptr = h.data;

		if((h.isNegative==true && fromAddFunc==false) || (h.isNegative==false && fromAddFunc==true)){
			// h is negative and this is negative; h - this
			// and this is longer
			result.isNegative = true;
		}

		else{
			result.isNegative = false;
		}

	}

	else if(h.length>this->length){
		// h data array (n) is larger than this data array (m)
		n=h.length;
		m=this->length;
		nptr = h.data;
		mptr = this->data;

		if((h.isNegative==true && fromAddFunc==false) || (h.isNegative==false && fromAddFunc==true)){
			// h is negative and this is negative; h - this
			// and h is longer
			result.isNegative = false;
		}
		else{
			result.isNegative = true;
		}
	}


	else{
		// the lengths must be EQUAL...
		// BAS u dont know which one will be n (numerator) or m (denominator)
		// because n has to be larger num

		// set up some dummy variables
		int hnum = 0;
		int thisnum = 0;
		// we know if it's - or + by comparing most significant digits, one after the other
		// most significant at beginning
		for(int i=0;i<h.length;i++){
			hnum=h.data[i];
			thisnum=this->data[i];
			if(hnum>thisnum){ // h is larger
				if((h.isNegative==true && fromAddFunc==false) || (h.isNegative==false && fromAddFunc==true)){result.isNegative=false;} // h - this w bigger h
				else{result.isNegative=true;} // this - h w bigger h
				n=h.length;
				m=this->length;
				nptr=h.data;
				mptr=this->data;
				break;
			}
			else if(hnum<thisnum){
				if((h.isNegative==true && fromAddFunc==false) || (h.isNegative==false && fromAddFunc==true)){result.isNegative=true;} // h - this w bigger this
				else{result.isNegative=false;} // this - h w bigger this
				n=this->length;
				m=h.length;
				nptr=this->data;
				mptr=h.data;
				break;
			}
			else{
				// if it's the last iteration, then the numbers are equal and result is 0
				if(i==h.length-1){
					result.isNegative=false;
					result.length=1;
					// dynamically allocate
					result.data = new int[result.length];
					// give values
					result.data[0]=0;
					return result;
				}
				// otherwise continue to next most significant digit
				continue;
			}
		}
	}

	// create temporary array for result knowing max size is n, size of larger int data aray
	int* temp_arr = new int [n];

	// make whichever one is longer the numerator (if it's negative, we'll have negative result)
	// loop through larger but have counters for both

	// temp array counter (in reverse since we can't delete bottom of array if there's empty slots)
	int j=0;

	// smaller array counter (starts at last index)
	int k=m-1;
	// make variable to hold "1" when we need to borrow
	int borrow1=0;
	int nval=0;

	for(int i=n-1;i>=0;i--){

		nval=nptr[i];

		if(nval==0 && borrow1==1){
			nval=9; // and borrow1 remains 1 since we couldn't borrow anything from here
		}

		else if(nval!=0 && borrow1==1){
			nval=nval-1; // we borrow 1 from the n value
			// now our borrow is back to 0
			borrow1=0;
		}
		// have to include to avoid dangling else
		else{
			nval=nval+0;
		}

		// take larger - smaller until k=0 (finished thru smaller), then take larger only
		if(k>=0){
			// we're still looping through smaller as well
			if(nval-mptr[k]<0){
				// we need to borrow from next one over
				borrow1 = 1;
				// we borrowed so we can add 10
				nval+=10;
			}
			// get the substraction
			temp_arr[j]=nval-mptr[k];
		}

		else{
			temp_arr[j]=nval;
		}

		// increment thru temp array
		j++;
		k--;
	}

	//printf("j1 %d \n",j);
	// we now have our diff. result but in the reverse order, stored in temp array

	// we need to get rid of ending 0s that might arise and set the size accordingly. there could be up to n-1 ending 0s.
	// j represents amount of data in temp_arr (length)
	// starting pos is thus j-1

	for(int i=j-1;i>=0;i--){
		if(temp_arr[i]==0){
			// delete element to prevent memory leak.. bas we don't have to because we're freeing at the end
			// decrease length of result
			j--;
			continue;
		}
		else{
			break;
			// we've hit a non zero entry so we have nothing more to delete
		}
	}

	result.length=j;
	result.data=new int[result.length];
	//printf("j2 %d \n",j);

	// result.length now stores number of elements in temp array --> based on for loop above
	// reverse temp array
	for(int i=0;i<result.length/2;i++){
		int temp=temp_arr[i];
		// preserve value
		temp_arr[i]=temp_arr[result.length-i-1];
		temp_arr[result.length-i-1]=temp;
	}

	// create pointer to point to beginning of result.data
	int* ptemp = result.data;

	int z=0;
	while(ptemp!=(result.data+result.length)){
		// while pointer is not out of range, that is address result.data has not incremented to past length
		// assign result.data value of temp_arr
		*ptemp = temp_arr[z];
		ptemp++;
		z++;
	}

	/*
	printf("before \n");
	for(int t=0;t<result.length;t++){printf("%d",result.data[t]);}
	printf("\n");
	*/

	// free space
	delete[] temp_arr;

	return result;
}

HugeInteger HugeInteger::multiply(const HugeInteger& h) {
	HugeInteger result;
	// get sign
	if(h.isNegative != this->isNegative){
		// then we have a +,- situation going on, which calls for - product
		result.isNegative = true;
	}
	else{
		// they have the same sign, so multiplication is +
		result.isNegative = false;
	}

	// 0 multiplication
	if(h.data[0]==0 || this->data[0]==0){
		result.length=1;
		result.isNegative=false;
		result.data=new int[result.length];
		result.data[0]=0;
		return result;
	}

	// n is size of LARGER array
	int n=0;
	// m is size of SHORTER array
	int m=0;
	// nptr is pointer to LARGER
	int* nptr;
	// mptr is pointer to SHORTER
	int* mptr;

	if(h.length<=this->length){
		// this data array (n) is larger than h data array (m)
		n=this->length;
		m=h.length;
		nptr = this->data;
		mptr = h.data;
	}
	else{
		// h data array (n) is larger than this data array (m)
		n=h.length;
		m=this->length;
		nptr = h.data;
		mptr = this->data;
	}

	// set temporary result array... length will be AT MOST sum of lengths of nums being multiplied
	// could have leading 0s
	int* result_arr = new int[n+m];

	// initialize carry (will serve for addition & multiplication)
	int carry=0;

	// initialize left shift (will let us iterate through 'columns' we are adding)
	int left_shift=0;
	int k=0;

	int tempprod=0; // for storing single multiplications
	int tempsum=0; // for storing partial additions of columns

	// outer loop will go through smaller number; inner loop will go through larger number
	for(int i=m-1;i>=0;i--){
		// get number we're multiplying top by
		int currentnum = mptr[i];
		// update k to newest left shift based on i we've reached in smaller number
		// 0 paddding
		k=left_shift;
		// reset carry to 0 since we're building upon a new row
		carry=0;

		for(int j=n-1;j>=0;j--){
			tempprod=nptr[j]*currentnum+carry;

			// if there's currently a value stored in this column k
			if(result_arr[k]>0){
				// add this previously stored value to our kth tempsum
				tempsum = tempprod+result_arr[k];
				// set NEXT value at [k++] for next iteration (increment k)
				result_arr[k++]=tempsum%10;
				// set ADDITION carry
				carry = tempsum/10;
			}
			// if there's nothing to add at this column k
			else{
				result_arr[k++]=tempprod%10;
				carry=tempprod/10;
			}
			//printf("k %d \n",k); // makes very clear how it's working
		}
		// breaking out of inner for loop, make sure first digit of row is carry if there's a carry
		if(carry>0){
			result_arr[k]=carry;
		}
		// increment left shift, so next time we start at an index k one further to the left
		left_shift++;
	}
	// remove leading 0s from result if there are any

	int index=(n+m)-1; // max index value in result array
	while(index>=0 && result_arr[index]==0){
		index--;
	}

	// copy over
	// index now contains value where leading 0s stop and number starts
	// issue is length could be index+1 or index
	// like if we have 11*11=121 or 99*99=2084
	result.length=index+1;
	result.data=new int[result.length];

	// initialize pointer to copy over to result
	int* tmpptr=result.data;

	// wanna reverse into data array
	for(int i=index;i>=0;i--){
		*tmpptr=result_arr[i];
		tmpptr++;
	}

	// print thru
		for(int i=0;i<index+1;i++){
		   //printf("%d",result.data[i]);
		   //printf("\n");
		}

	// can now get length of data array (number of times we go through for loop)
	// or result.length = m+n-1

	// free space
	//delete[] result_arr;

	return result;
}

// return 0 if equal
// return -1 if this is smaller than h
// return 1 if this is bigger than h
int HugeInteger::compareTo(const HugeInteger& h) {
	int result=0;
	int* nptr;
	int* mptr;
	nptr=h.data;
	mptr=this->data;
	int n=0;
	if(h.isNegative==true && this->isNegative==false){
		result=1;
	}
	else if(h.isNegative==false && this->isNegative==true){
		result=-1;
	}
	else if(h.isNegative==false && this->isNegative==false){
		if(h.length>this->length){result=-1;}
		else if(h.length<this->length){result=1;}
		else{
			n=h.length;
			for(int i=0;i<n;i++){
				if(nptr[i]>mptr[i]){
					result=-1;
					break;
				}
				else if(nptr[i]<mptr[i]){
					result=1;
					break;
				}
				else{
					continue;
				}
			}
		}
	}
	else if(h.isNegative==true && this->isNegative==true){
		if(h.length>this->length){result=1;}
		else if(h.length<this->length){result=-1;}
		else{
			n=h.length;
			for(int i=0;i<n;i++){
				if(nptr[i]>mptr[i]){
					result=1;
					break;
				}
				else if(nptr[i]<mptr[i]){
					result=-1;
					break;
				}
				else{
					continue;
				}
			}
		}
	}
	return result;
}

// taking array of ints and convert it to string
std::string HugeInteger::toString() {

	// initialize string - strings in c++ are stored in the stack (not the heap), so they are allocated dynamically by default (dont need NEW keyword) resizable during runtime
	string output_string;

	if(isNegative==true){
		output_string.push_back('-');
	}

	for(int j=0;j<length;j++){
		// add '0' to cast to char type from int type
		char temp = data[j]+'0';
		// append to string (concatenate our temp char into output_string)
		output_string.push_back(temp);
	}

	//printf("tostring s %s \n",output_string.c_str());
	return output_string;
}
