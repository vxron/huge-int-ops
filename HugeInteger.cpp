#include "HugeInteger.h"
#include <random>
#include <algorithm>
#include <stdexcept>
#include <ctime>

// CONSTRUCTOR: default (we'll just output int 1 if no input is given)
HugeInteger::HugeInteger(){
	isNegative=false;
	length=1;
	// dynamically allocate space for int array of length 1 into DATA
	data = new int [length];
}

// CONSTRUCTOR: create HugeInt based on string
HugeInteger::HugeInteger(const string& val) {

	// error handling with array and pointer
	char possible_digits[10]={'0','1','2','3','4','5','6','7','8','9'};
	char *p2;
	char possible_first_digit[11]={'-','0','1','2','3','4','5','6','7','8','9'};
	char *p1;

	// error handling - first digit of val string
	// iterate pointer thru addresses of first digit array and check if val[0] is there
	p1 = find(possible_first_digit, possible_first_digit+11, val[0]);

	// find returns pointer to last element if it doesn't find val[0]
	if(p1 == possible_first_digit+11){
		// invalid first digit, invalid input
		// throw exception
		throw invalid_argument("Invalid string input. Make sure first digit is '-' or 1-9.");
		// throw immediately terminates execution (no need for return)
	}


	// error handling - following digits of val string
	for(unsigned int i=1;i<val.size();i++){
		p2 = find(possible_digits,possible_digits+10,val[i]);
		if(p2 == possible_digits+10){
			// val[i] was not found in list of acceptable digits
			throw invalid_argument("Invalid string input. Make sure you're using decimals 0-9.");
		}
	}



	// if it's negative, so there's a dash at beginning
	if(val[0]=='-'){
		isNegative=1; // true
		// length (num. of DIGITS) will be string size - 1 for "-"
		length=val.size()-1;
		// testing purposes
		printf("size %d \n",length);

	}
	// if it's not negative, so there's no dash
	else{
		isNegative=0; // false
		// length is just length of string
		length=val.size();
		// testing purposes
		printf("size %d \n",length);

	}

	// initialize data array (NVM:+ allocate memory space with 'new' keyword)
	// everything is initialized to 0
	// kinda like a placeholder for the space
	// resizing data for storing array
	data = new int [length];

	// pointer to val
	const char* p = &val[0];
	if(*p=='-'){
		// increment position by 1 (p++ increments by size of char)
		p++;
	}

	// iterate through string to fill dynamically allocated array
	// BUT WE USE POINTER P instead of val to avoid negative at beginning
	for(int i=0;i<length;i++){
		printf("%c \n",p[i]);
		data[i] = p[i];
		// append string decimal to our data array
		// testing purposes
		printf("1 %d \n",data[i]);
	}

	// testing purposes
	for(int i=0;i<length;i++){
		printf("r %d \n",data[i]);
	}

}

// CONSTRUCTOR: create random HugeInteger of n digits
// workss on online gdb
HugeInteger::HugeInteger(int n) {
	// error handling
	if(n<1){
		throw invalid_argument("Invalid decimal input. Make sure you're entering an integer >0.");
	}

	// define a random device
	random_device rd;
	// standard mersenne_twister_engine seeded with rd()
	// static means (whenever u call huge integer, counter doesn't get restarted)
	// unsigned means itll go back to 0 after reaching max (if we called function thatt many times)
	static int unsigned counter=0;
	//+n randomized it (the seed)
	mt19937 gen(counter+n);
	// gives constantly a new seed to GEN (random number gen) so that there's a new sequence - new value - each time we call function
	counter++;
	uniform_int_distribution<int>distr(0,9);

	// decide sign using a pseudorandom operation
	// random number generated by distrib(gen)
	if (distr(gen)-5>=0){
		// negative if the random number is 5,6,7,8,9
		isNegative=1;
		// testing purposes
		printf("negative \n");
		printf("r %d \n",distr(gen));
		printf("r %d \n",distr(gen));
		printf("r %d \n",distr(gen));
	}
	else{
		// positive if the random number is 0,1,2,3,4
		isNegative=0;
		// testing purposes
		printf("positive \n");
		printf("r %d \n",distr(gen));
		printf("r %d \n",distr(gen));
		printf("r %d \n",distr(gen));
	}

	length=n;

	// initialize data array
	data = new int [length];

	// first digit can't be a 0
	//maybe it can be lol - COME BACK

	// randomly generate digits
	for(int i=0;i<n;i++){
		// generate consecutive random digits
		data[i]=distr(gen);
		// testing purposes
		printf("%d",data[i]);
		printf("\n");
	}


	// test to see wus happening


}

// Copy Constructor --ensure we wont have memory space issures with destructor (see below)
HugeInteger::HugeInteger(const HugeInteger& num){
	// this-> notation is implicit here
	isNegative=num.isNegative;
	length=num.length;
	// allocate data array
	data = new int [length];
	for(int i=0;i<length;i++){
		data[i]=num.data[i];
	}

}


// DESTRUCTOR
// must delete things stored in the heap because they are static (never get deleted otherwise)
// dont have to delete things stored in the stack (not dynamically allocated) because they get deleted automatically at the end of the function call
HugeInteger::~HugeInteger(){
	// array deletion syntax
	delete[] data;
}


/*
int a(){
	HugeInteger A(3);
	HugeInteger B();
	B=A;
}
*/

HugeInteger HugeInteger::add(const HugeInteger& h) {
	// TODO
	return HugeInteger("");
}

HugeInteger HugeInteger::subtract(const HugeInteger& h) {
	// TODO
	return HugeInteger("");
}

HugeInteger HugeInteger::multiply(const HugeInteger& h) {
	// TODO
	return HugeInteger("");
}

int HugeInteger::compareTo(const HugeInteger& h) {
	// TODO
	return 0;
}

std::string HugeInteger::toString() {
	// taking array of ints and convert it to string (if its negative, add "-", all this)

	//string output_string = new char[];

	for(int i=0;i<length;i++){

	}
	//return output_string;
}
