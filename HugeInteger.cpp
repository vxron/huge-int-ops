#include "HugeInteger.h"
#include <random>
#include <algorithm>
#include <stdexcept>
#include <ctime>

// CONSTRUCTOR: default (we'll just output int 1 if no input is given)
HugeInteger::HugeInteger(){
	isNegative=false;
	length=1;
	// dynamically allocate space for int array of length 1 into DATA
	data = new int [length];
}

// CONSTRUCTOR: create HugeInt based on string
HugeInteger::HugeInteger(const string& val) {

	// error handling with array and pointer
	char possible_digits[10]={'0','1','2','3','4','5','6','7','8','9'};
	char *p2;
	char possible_first_digit[11]={'-','0','1','2','3','4','5','6','7','8','9'};
	char *p1;

	// error handling - first digit of val string
	// iterate pointer thru addresses of first digit array and check if val[0] is there
	p1 = find(possible_first_digit, possible_first_digit+11, val[0]);

	// find returns pointer to last element if it doesn't find val[0]
	if(p1 == possible_first_digit+11){
		// invalid first digit, invalid input
		// throw exception
		throw invalid_argument("Invalid string input. Make sure first digit is '-' or 1-9.");
		// throw immediately terminates execution (no need for return)
	}


	// error handling - following digits of val string
	for(unsigned int i=1;i<val.size();i++){
		p2 = find(possible_digits,possible_digits+10,val[i]);
		if(p2 == possible_digits+10){
			// val[i] was not found in list of acceptable digits
			throw invalid_argument("Invalid string input. Make sure you're using decimals 0-9.");
		}
	}


	// if it's negative, so there's a dash at beginning
	if(val[0]=='-'){
		isNegative=1; // true
		// length (num. of DIGITS) will be string size - 1 for "-"
		length=val.size()-1;
	}
	// if it's not negative, so there's no dash
	else{
		isNegative=0; // false
		// length is just length of string
		length=val.size();
	}

	// allocate memory space for data array with 'new' keyword; everything is initialized to 0
	// kinda like a placeholder for the space
	data = new int [length];

	// create pointer to val (input string)
	const char* p = &val[0];
	if(*p=='-'){
		// increment position by 1 (p++ increments by size of char) if there's a negative at val[0]
		p++;
	}

	// iterate through string to fill dynamically allocated array
	// BUT WE USE POINTER p instead of val to avoid negative at beginning (p starts at val[0] if it's a digit, and starts at val[1] if not, continues until we reach length of data array, not including "-")
	for(int i=0;i<length;i++){
		// convert from ascii by adding '0'
		data[i] = p[i]-'0';
	}

	// testing purposes
	/*
	for(int i=0;i<length;i++){
		printf("r %d \n",data[i]);
	}
	*/

}

// CONSTRUCTOR: create random HugeInteger of n digits
HugeInteger::HugeInteger(int n) {
	// error handling
	if(n<1){
		throw invalid_argument("Invalid decimal input. Make sure you're entering an integer >0.");
	}


	// static means (whenever u call huge integer, counter doesn't get restarted, so it keeps incrementing)
	// unsigned means it'll go back to 0 after reaching max (if we called function thatt many times)
	static int unsigned counter=0;
	// standard mersenne_twister_engine seeded with counter (defined above) + n
	mt19937 gen(counter+n);
	// gives constantly a new seed to GEN so that there's a new sequence - new value - each time we call function
	counter++;
	uniform_int_distribution<int>distr(0,9);

	// decide sign using a pseudorandom operation
	// random number generated by distrib(gen)
	if (distr(gen)-5>=0){
		// negative if the random number is 5,6,7,8,9
		isNegative=1;
		// testing purposes
		printf("negative \n");
	}
	else{
		// positive if the random number is 0,1,2,3,4
		isNegative=0;
		// testing purposes
		printf("positive \n");
	}

	length=n;

	// initialize & allocate data array
	data = new int [length];


	// use a while loop to make sure data[0] isn't 0
	// so we'll keep looping until it gives something other than 0 to start with
	*data=0;
	while(*data==0){
		// assigning value *data = data[0]
		*data=distr(gen);
	}

	// randomly generate remaining digits
	// starting at 1 cuz we already got data[0] above to make sure it wasn't 0
	for(int i=1;i<n;i++){
		data[i]=distr(gen);
	}


}

// COPY CONSTRUCTOR --ensure we wont have memory space issues with destructor (rule of 3... see below)
HugeInteger::HugeInteger(const HugeInteger& num){
	// this-> notation is implicit here
	isNegative=num.isNegative;
	length=num.length;
	// allocate data array
	data = new int [length];
	for(int i=0;i<length;i++){
		data[i]=num.data[i];
	}

}


// DESTRUCTOR
// must delete things stored in the heap (dynamically allocated) because they are static (never get deleted otherwise)
// don't have to delete things stored in the stack (not dynamically allocated) because they get deleted automatically at the end of the function call
HugeInteger::~HugeInteger(){
	// array deletion syntax
	delete[] data;
}


HugeInteger HugeInteger::add(const HugeInteger& h) {
	HugeInteger result;

	// see if we're gonna need substraction or addition
	if(h.isNegative != this->isNegative){
		// then we have a +,- situation going on, which calls for subtraction
		this->HugeInteger::subtract(h);
	}
	else if(h.isNegative == true && this->isNegative == true){
		// both numbers are negative, so sum hugeint will also be negative
		result.isNegative = true;
	}
	else{
		result.isNegative=false;
	}


	// length will be at most one digit longer than greatest size (1 digit more due to carry)
	// get iteration number n --> run through size of greatest array
	// declare n outside of if scope... size of LARGER array (we don't yet know which one...)
	int n=0;
	// m is size of SHORTER array
	int m=0;

	// initialize pointers to bigger/smaller arrays
	// nptr is pointer to LARGER
	int* nptr;
	// mptr is pointer to SHORTER
	int* mptr;

	if(h.length<=this->length){
		// this data array (n) is larger than h data array (m)
		n=this->length;
		m=h.length;
		nptr = this->data;
		mptr = h.data;
	}
	else{
		// h data array (n) is larger than this data array (m)
		n=h.length;
		m=this->length;
		nptr = h.data;
		mptr = this->data;
	}

	/*
	// print arrays - testing purposes
	int* ntemp = nptr;
	int* mtemp = mptr;

	printf("big \n");
	for(int t=0;t<n;t++){printf("%d",*ntemp);ntemp++;}
	printf("\n");

	printf("smol \n");
	for(int t=0;t<m;t++){printf("%d",*mtemp);mtemp++;}
	printf("\n");
	*/

	// allocate memory for result's data
	// but we don't know the exact length yet, so we'll allocate a temporary array
	// we know the max length is n+1
	int* temp_arr = new int [n+1];


	// initialize carry
	int carry=0;

	// arrays must be add in reverse direction (starting with ones column)
	// we'll assign values to temp_arr using "reverse" indexing cuz we wanna add carry or not at the END, depending, without having to shift entire array
	// so we'll reverse our temp data array instead of shifting all the data

	// j serves as variable to loop thru temp_array in a forwards direction
	// notice j keeps track of how many elements there are in temp array (we'll use this later)
	int j=0;

	// smaller array counter (m with k)
	int k=m-1;

	// larger array counter (n with i) - drives for loop
	for(int i=n-1;i>=0;i--){

		int tempsum = 0;

		// take larger + smaller until k=0 (finished thru smaller), then take larger only (+ any carry of course)
		if(k>=0){
			tempsum = nptr[i]+mptr[k]+carry;
		}

		else{
			// now we only want larger (n with i)
			tempsum = nptr[i]+carry;
		}

		// find resulting (last) digit (ones place of temp)
		temp_arr[j]=tempsum%10;

		// find carry (first) value (tens place of temp)
		// but we know max value of temp will be <100, so integer division comes clutch here
		carry=tempsum/10;

		// increment j - looping thru temp array
		j++;
		// decrement k - looping thru smaller array (backwards)
		k--;
	}

	// if we terminate with non zero carry, our length will be n+1
	// result array will take values of temp_array IN REVERSE + value of carry
	if(carry!=0){
		result.length=n+1;
		// allocate data
		result.data = new int [result.length];
		result.data[0]=carry;
	}
	else{
		// otherwise, length is simply n
		result.length=n;
		result.data = new int [result.length];
	}

	/*
	// print temp array
	printf("before \n");
	for(int t=0;t<j;t++){printf("%d",temp_arr[t]);}
	printf("\n");
	*/

	// j stores number of elements in temp array --> based on for loop above
	// reverse temp array
	for(int i=0;i<j/2;i++){
		int temp=temp_arr[i];
		// preserve value
		temp_arr[i]=temp_arr[j-i-1];
		temp_arr[j-i-1]=temp;
	}

	/*
	// print temp array
	printf("after \n");
	for(int t=0;t<j;t++){printf("%d",temp_arr[t]);}
	printf("\n");
	*/

	// create pointer to point to beginning of result.data
	int* ptemp = result.data;

	if(carry!=0){
		ptemp++;
		// start at index 1 of result.data instead of 0, cuz we've already assigned result.data[0]=carry
		// but STILL INDEX 0 OF TEMP_ARR (we'll use z for this)
	}

	int z=0;

	while(ptemp!=(result.data+result.length)){
		// while pointer is not out of range, that is address result.data has not incremented to past length
		// assign result.data value of temp_arr
		*ptemp = temp_arr[z];
		ptemp++;
		z++;
	}

	// free space
	delete[] temp_arr;

	return result;

}

HugeInteger HugeInteger::subtract(const HugeInteger& h) {
	// TODO
	return HugeInteger("");
}

HugeInteger HugeInteger::multiply(const HugeInteger& h) {
	// TODO
	return HugeInteger("");
}

int HugeInteger::compareTo(const HugeInteger& h) {
	// TODO
	return 0;
}

// taking array of ints and convert it to string
std::string HugeInteger::toString() {

	// initialize string - strings in c++ are stored in the stack (not the heap), so they are allocated dynamically by default (dont need NEW keyword) resizable during runtime
	string output_string;

	if(isNegative==true){
		output_string.push_back('-');
	}

	for(int j=0;j<length;j++){
		// add '0' to cast to char type from int type
		char temp = data[j]+'0';
		// append to string (concatenate our temp char into output_string)
		output_string.push_back(temp);
	}

	printf("tostring s %s \n",output_string.c_str());
	return output_string;
}
