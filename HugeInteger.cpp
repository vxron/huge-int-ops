#include "HugeInteger.h"
#include <random>
#include <algorithm>
#include <stdexcept>
#include <ctime>

// CONSTRUCTOR: default (we'll just output int 1 if no input is given)
HugeInteger::HugeInteger(){
	isNegative=false;
	length=1;
	// dynamically allocate space for int array of length 1 into DATA
	data = new int [length];
}

// CONSTRUCTOR: create HugeInt based on string
HugeInteger::HugeInteger(const string& val) {

	// error handling with array and pointer
	char possible_digits[10]={'0','1','2','3','4','5','6','7','8','9'};
	char *p2;
	char possible_first_digit[11]={'-','0','1','2','3','4','5','6','7','8','9'};
	char *p1;

	// error handling - first digit of val string
	// iterate pointer thru addresses of first digit array and check if val[0] is there
	p1 = find(possible_first_digit, possible_first_digit+11, val[0]);

	// find returns pointer to last element if it doesn't find val[0]
	if(p1 == possible_first_digit+11){
		// invalid first digit, invalid input
		// throw exception
		throw invalid_argument("Invalid string input. Make sure first digit is '-' or 1-9.");
		// throw immediately terminates execution (no need for return)
	}


	// error handling - following digits of val string
	for(unsigned int i=1;i<val.size();i++){
		p2 = find(possible_digits,possible_digits+10,val[i]);
		if(p2 == possible_digits+10){
			// val[i] was not found in list of acceptable digits
			throw invalid_argument("Invalid string input. Make sure you're using decimals 0-9.");
		}
	}



	// if it's negative, so there's a dash at beginning
	if(val[0]=='-'){
		isNegative=1; // true
		// length (num. of DIGITS) will be string size - 1 for "-"
		length=val.size()-1;
		// testing purposes
		//printf("size %d \n",length);

	}
	// if it's not negative, so there's no dash
	else{
		isNegative=0; // false
		// length is just length of string
		length=val.size();
		// testing purposes
		//printf("size %d \n",length);

	}

	// initialize data array (NVM:+ allocate memory space with 'new' keyword)
	// everything is initialized to 0
	// kinda like a placeholder for the space
	// resizing data for storing array
	data = new int [length];

	// pointer to val
	const char* p = &val[0];
	if(*p=='-'){
		// increment position by 1 (p++ increments by size of char)
		p++;
	}

	// iterate through string to fill dynamically allocated array
	// BUT WE USE POINTER P instead of val to avoid negative at beginning
	for(int i=0;i<length;i++){
		//printf("%c \n",p[i]);
		// convert from ascii by adding '0'
		data[i] = p[i]-'0';
		// append string decimal to our data array
		// testing purposes
		//printf("1 %d \n",data[i]);
	}

	// testing purposes
	/*
	for(int i=0;i<length;i++){
		printf("r %d \n",data[i]);
	}
	*/

}

// CONSTRUCTOR: create random HugeInteger of n digits
// workss on online gdb
HugeInteger::HugeInteger(int n) {
	// error handling
	if(n<1){
		throw invalid_argument("Invalid decimal input. Make sure you're entering an integer >0.");
	}

	// define a random device
	random_device rd;
	// standard mersenne_twister_engine seeded with rd()
	// static means (whenever u call huge integer, counter doesn't get restarted)
	// unsigned means itll go back to 0 after reaching max (if we called function thatt many times)
	static int unsigned counter=0;
	//+n randomized it (the seed)
	mt19937 gen(counter+n);
	// gives constantly a new seed to GEN (random number gen) so that there's a new sequence - new value - each time we call function
	counter++;
	uniform_int_distribution<int>distr(0,9);

	// decide sign using a pseudorandom operation
	// random number generated by distrib(gen)
	if (distr(gen)-5>=0){
		// negative if the random number is 5,6,7,8,9
		isNegative=1;
		// testing purposes
		printf("negative \n");
	}
	else{
		// positive if the random number is 0,1,2,3,4
		isNegative=0;
		// testing purposes
		printf("positive \n");
	}

	length=n;

	// initialize data array
	data = new int [length];

	// first digit can't be a 0
	//maybe it can be lol - COME BACK

	// use a while loop (xav is insane)
	// make sure data[0] isn't 0
	// so we'll keep looping until it gives something other than 0 to start with
	*data=0;
	while(*data==0){
		// assigning value *data = data[0]
		*data=distr(gen);
	}

	// randomly generate digits
	// starting at 1 cuz we already got data[0] above to make sure it wasn't 0
	for(int i=1;i<n;i++){
		// generate consecutive random digits
		data[i]=distr(gen);
		// testing purposes
		//printf("%d",data[i]);
		//printf("\n");
	}


	// test to see wus happening


}

// Copy Constructor --ensure we wont have memory space issues with destructor (see below)
HugeInteger::HugeInteger(const HugeInteger& num){
	// this-> notation is implicit here
	isNegative=num.isNegative;
	length=num.length;
	// allocate data array
	data = new int [length];
	for(int i=0;i<length;i++){
		data[i]=num.data[i];
	}

}


// DESTRUCTOR
// must delete things stored in the heap because they are static (never get deleted otherwise)
// dont have to delete things stored in the stack (not dynamically allocated) because they get deleted automatically at the end of the function call
HugeInteger::~HugeInteger(){
	// array deletion syntax
	delete[] data;
}


/*
int a(){
	HugeInteger A(3);
	HugeInteger B();
	B=A;
}
*/

HugeInteger HugeInteger::add(const HugeInteger& h) {
	HugeInteger result;

	// collect and store information/attributes
	/*
	int hlength = h.length;
	int thislength = this->length;
	bool hneg = h.isNegative;
	bool thisneg = this->isNegative;
	*/

	// see if we're gonna need substraction or addition
	if(h.isNegative != this->isNegative){
		// then we have a +,- situation going on, which calls for subtraction
		this->HugeInteger::subtract(h);
	}
	else if(h.isNegative == true && this->isNegative == true){
		// both numbers are negative, so sum hugeint will also be negative
		result.isNegative = true;
	}
	else{
		result.isNegative=false;
	}

	// case where both numbers are positive


	// length will be at most one digit longer than greatest size

	// get iteration number n --> run through size of greatest array
	// declare n outside of if scope
	// n is size of bigger array
	int n=0;
	// m is size of smaller array
	int m=0;
	// initialize pointers
	// n is pointer to bigger
	int* nptr;
	// m is pointer to smaller
	int* mptr;
	if(h.length<=this->length){
		// loop through this length
		n=this->length;
		m=h.length;
		// initialize pointers indicating diff sized arrays
		nptr = this->data;
		mptr = h.data;
	}
	else{
		// loop through alternate h
		n=h.length;
		m=this->length;
		// initialize pointers indicating diff sized arrays
		nptr = h.data;
		mptr = this->data;
	}

	// print big array
	int* ntemp = nptr;
	int* mtemp = mptr;
	printf("big \n");
	for(int t=0;t<n;t++){printf("%d",*ntemp);ntemp++;}
	printf("\n");

	// print smol array
	printf("smol \n");
	for(int t=0;t<m;t++){printf("%d",*mtemp);mtemp++;}
	printf("\n");

	// allocate memory for result's data
	// but we don't know length yet, so we'll allocate temporary array
	// know max length is n+1
	int* temp_arr = new int [n+1];


	// initialize carry
	int carry=0;


	// variable to loop thru temp_array cuz we index 0->n here
	// want this "reverse" indexing here cuz we wanna add carry or not at end, depending, without having to shift entire array
	// so we'll reverse our data instead of shifting
	// notice j keeps track of how many
	int j=0;
	// smaller array counter (m with k)
	int k=m-1;
	// larger array counter (n with i)
	for(int i=n-1;i>=0;i--){

		int tempsum = 0;

		// take larger + smaller until k=0, then take larger only
		if(k>=0){
			tempsum = nptr[i]+mptr[k]+carry;
		}

		else{
			// now we only want larger (n with i)
			tempsum = nptr[i]+carry;
		}

		// find resulting (last) digit (ones place of temp)
		temp_arr[j]=tempsum%10;
		// find carry (first) value (tens place of temp)
		// but we know max value of temp will be <100
		// integer division comes clutch here
		carry=tempsum/10;
		j++;
		k--;
	}

	// if we terminate with non zero carry, our length will be n+1
	// result array will take values of temp_array IN REVERSE + value of carry
	if(carry!=0){
		result.length=n+1;
		// allocate data
		result.data = new int [result.length];
		result.data[0]=carry;
	}
	else{
		result.length=n;
		// allocate data
		result.data = new int [result.length];
	}

	// print temp array
	printf("before \n");
	for(int t=0;t<j;t++){printf("%d",temp_arr[t]);}
	printf("\n");


	// j stores number of elements in temp array --> based on loop above
	// reverse temp array
	for(int i=0;i<j/2;i++){
		int temp=temp_arr[i];
		// preserve value
		temp_arr[i]=temp_arr[j-i-1];
		temp_arr[j-i-1]=temp;
	}

	// print temp array
	printf("after \n");
	for(int t=0;t<j;t++){printf("%d",temp_arr[t]);}
	printf("\n");


	// create pointer to point to beginning of temp_arr
	int* ptemp = result.data;

	if(carry!=0){
		ptemp++;
		// start at index 1 of result.data instead of 0
		// bas STILL INDEX 0 OF TEMP_ARR
	}

	// counter for temp_array
	// adds 1 if carry is true
	int z=0;

	while(ptemp!=(result.data+result.length)){
		// while pointer is not out of range, that is address result.data has not incremented to past length
		*ptemp = temp_arr[z];
		// dereferencing
		ptemp++;
		z++;
	}

	// print result array
	printf("after after result \n");
	for(int t=0;t<result.length;t++){printf("%d",result.data[t]);}
	printf("\n");



	/*
	const HugeInteger& a = h;
	const HugeInteger& b = *this;
	int i = a.length > b.length ? a.length : b.length;
	int j = a.length < b.length ? a.length : b.length;
	int carry = 0;
	int k = 0;
	int len = 0;
	do {
	  if(!i--) break;
	  if(!j--) break;
	  int ts = a.data[i] + b.data[j] + carry;
	  temp_arr[k++] = ts % 10;
	  carry /= 10;
	  len++;
	} while(carry);
	result.data = new int[len];
	for(int x = 0; x < len; x++){
	  result.data[len - x - 1] = temp_arr[x];
	}
	result.length=len;
	*/

	// free space
	delete[] temp_arr;

	return result;

}

HugeInteger HugeInteger::subtract(const HugeInteger& h) {
	// TODO
	return HugeInteger("");
}

HugeInteger HugeInteger::multiply(const HugeInteger& h) {
	// TODO
	return HugeInteger("");
}

int HugeInteger::compareTo(const HugeInteger& h) {
	// TODO
	return 0;
}

std::string HugeInteger::toString() {
	// taking array of ints and convert it to string (if its negative, add "-", all this)

	//initialize string - strings in c++ are stored in the stack (not the heap), so they are allocated dynamically by default (dont need NEW keyword) resizable during runtime
	string output_string;

	// pointer to iterate thru string
	// char* p = output_string;
	// string::iterator it;
	// (stores address of a character of str)
	//it=output_string.begin();

	if(isNegative==true){
		output_string.push_back('-');
		// pointer to go through output string
		// increment it by 1 so we start at first digit rather than negative sign (in line w data array)

	}

	for(int j=0;j<length;j++){
		// convert list int to char
		// add '0' to cast to char type from int type

		char temp = data[j]+'0';
		//printf("d %d \n",data[j]);
		// append to string (concatenate our temp char into output_string)
		output_string.push_back(temp);
	}

	printf("tostring s %s \n",output_string.c_str());
	return output_string;
}
